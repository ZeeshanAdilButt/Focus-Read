{"version":3,"file":"sidepanel.js","mappings":"AAAA","sources":["webpack://focus-read/./src/sidepanel/sidepanel.js"],"sourcesContent":["document.addEventListener('DOMContentLoaded', () => {\r\n    // UI Elements\r\n    const wordDisplay = document.getElementById('wordDisplay');\r\n    const playPauseBtn = document.getElementById('playPauseBtn');\r\n    const prevBtn = document.getElementById('prevBtn');\r\n    const nextBtn = document.getElementById('nextBtn');\r\n    const restartBtn = document.getElementById('restartBtn');\r\n    const wpmInput = document.getElementById('wpmInput');\r\n    const wpmDisplay = document.getElementById('wpmDisplay');\r\n    const progressBar = document.getElementById('progressBar');\r\n    const progressText = document.getElementById('progressText');\r\n    const timeRemaining = document.getElementById('timeRemaining');\r\n    const settingsBtn = document.getElementById('settingsBtn');\r\n    const settingsOverlay = document.getElementById('settingsOverlay');\r\n    const closeSettingsBtn = document.getElementById('closeSettingsBtn');\r\n    const chunkSizeInput = document.getElementById('chunkSizeInput');\r\n    const scanPageBtn = document.getElementById('scanPageBtn');\r\n    const openPdfBtn = document.getElementById('openPdfBtn');\r\n    const setTextBtn = document.getElementById('setTextBtn');\r\n    const clearTextBtn = document.getElementById('clearTextBtn');\r\n    const manualInputOverlay = document.getElementById('manualInputOverlay');\r\n    const manualTextInput = document.getElementById('manualTextInput');\r\n    const loadInputBtn = document.getElementById('loadInputBtn');\r\n    const cancelInputBtn = document.getElementById('cancelInputBtn');\r\n    const toast = document.getElementById('toast');\r\n    const toastMessage = document.getElementById('toastMessage');\r\n    const fullscreenBtn = document.getElementById('fullscreenBtn');\r\n    const readerDisplay = document.getElementById('readerDisplay');\r\n\r\n    // Settings UI Elements\r\n    const togglePausesBtn = document.getElementById('togglePausesBtn');\r\n    const toggleLoopBtn = document.getElementById('toggleLoopBtn');\r\n    const pauseScaleSlider = document.getElementById('pauseScaleSlider');\r\n    const pauseScaleInput = document.getElementById('pauseScaleInput');\r\n    const fontSelect = document.getElementById('fontSelect');\r\n    const fontScaleSlider = document.getElementById('fontScaleSlider');\r\n    const fontScaleInput = document.getElementById('fontScaleInput');\r\n    const bgColorPicker = document.getElementById('bgColorPicker');\r\n    const bgColorText = document.getElementById('bgColorText');\r\n    const textColorPicker = document.getElementById('textColorPicker');\r\n    const textColorText = document.getElementById('textColorText');\r\n    const focusColorPicker = document.getElementById('focusColorPicker');\r\n    const focusColorText = document.getElementById('focusColorText');\r\n    const resetSettingsBtn = document.getElementById('resetSettingsBtn');\r\n    const navModeSelect = document.getElementById('navModeSelect');\r\n    const navAmountInput = document.getElementById('navAmountInput');\r\n\r\n    // State\r\n    let words = [];\r\n    let currentIndex = 0;\r\n    let isPlaying = false;\r\n    let timer = null; // Used for \"next step\" timeout\r\n    \r\n    // Config\r\n    let config = {\r\n        wpm: 300,\r\n        chunkSize: 1,\r\n        mode: 'word', // 'word' or 'sentence'\r\n        pauses: true,\r\n        loop: false,\r\n        pauseScale: 1.5,\r\n        font: \"'Segoe UI', sans-serif\",\r\n        fontScale: 1,\r\n        bgColor: '#000000',\r\n        textColor: '#ffffff',\r\n        focusColor: '#e74c3c',\r\n        navMode: 'paragraphs', // 'seconds', 'words', 'sentences', 'paragraphs'\r\n        navAmount: 1\r\n    };\r\n\r\n    // Toast notification helper\r\n    function showToast(message, duration = 2500) {\r\n        if (!toast || !toastMessage) return;\r\n        toastMessage.textContent = message;\r\n        toast.classList.remove('hidden');\r\n        // Force reflow before adding show class\r\n        toast.offsetHeight;\r\n        toast.classList.add('show');\r\n        \r\n        setTimeout(() => {\r\n            toast.classList.remove('show');\r\n            setTimeout(() => toast.classList.add('hidden'), 300);\r\n        }, duration);\r\n    }\r\n\r\n    // UI Elements for Mode\r\n    const modeWordBtn = document.getElementById('modeWordBtn');\r\n    const modeSentenceBtn = document.getElementById('modeSentenceBtn');\r\n    const chunkSizeContainer = document.getElementById('chunkSizeContainer');\r\n    const sentenceLengthContainer = document.getElementById('sentenceLengthContainer');\r\n\r\n    // --- ORP Logic (Optimal Recognition Point) ---\r\n    function formatWord(word) {\r\n        if (!word) return \"&nbsp;\";\r\n        // Clean the word of extra whitespace\r\n        word = word.trim();\r\n        if (!word) return \"&nbsp;\";\r\n        \r\n        // Calculate ORP (Optimal Recognition Point) - typically around 1/3 into the word\r\n        // For short words (1-3 chars), highlight first char\r\n        // For medium words (4-7 chars), highlight ~25-35% position\r\n        // For long words (8+), highlight ~30% position\r\n        let idx;\r\n        const len = word.length;\r\n        if (len <= 1) {\r\n            idx = 0;\r\n        } else if (len <= 3) {\r\n            idx = 0; // First letter for short words\r\n        } else if (len <= 7) {\r\n            idx = Math.floor(len * 0.3); // ~30% for medium\r\n        } else {\r\n            idx = Math.floor(len * 0.28); // ~28% for long words\r\n        }\r\n        \r\n        const start = word.slice(0, idx);\r\n        const char = word.slice(idx, idx + 1);\r\n        const end = word.slice(idx + 1);\r\n        \r\n        return `${start}<span class=\"highlight-char\" style=\"color: ${config.focusColor}\">${char}</span>${end}`;\r\n    }\r\n    \r\n    // Format multiple words with ORP on each\r\n    function formatChunk(text) {\r\n        if (!text) return \"&nbsp;\";\r\n        const words = text.trim().split(/\\s+/);\r\n        return words.map(w => formatWord(w)).join(' ');\r\n    }\r\n\r\n    // --- Core Reader Logic ---\r\n\r\n    // Calculate base interval (ms per word/chunk)\r\n    function getIntervalForChunk(chunkText, isSentence) {\r\n        // Base calculation: ms per word = 60000 / WPM\r\n        const msPerWord = 60000 / config.wpm;\r\n        \r\n        if (isSentence && chunkText) {\r\n            // For sentences, count actual words\r\n            const wordCount = chunkText.trim().split(/\\s+/).length;\r\n            return msPerWord * wordCount;\r\n        } else {\r\n            // For word mode, multiply by chunk size\r\n            return msPerWord * config.chunkSize;\r\n        }\r\n    }\r\n\r\n    function updateDisplay() {\r\n        // Apply styles\r\n        document.body.style.backgroundColor = config.bgColor;\r\n        wordDisplay.style.color = config.textColor;\r\n        wordDisplay.style.fontFamily = config.font;\r\n        \r\n        // Adjust font size based on mode and chunk size\r\n        let baseSize = 3; // Default for single word\r\n        if (config.mode === 'sentence') {\r\n            baseSize = 1.5;\r\n        } else if (config.chunkSize > 1) {\r\n            // Scale down for multiple words: 2 words = 2.5rem, 3 words = 2rem, etc.\r\n            baseSize = Math.max(1.5, 3 - (config.chunkSize - 1) * 0.5);\r\n        }\r\n        wordDisplay.style.fontSize = `${baseSize * config.fontScale}rem`;\r\n        \r\n        // Enable wrapping for multi-word or sentence mode\r\n        wordDisplay.style.whiteSpace = (config.mode === 'sentence' || config.chunkSize > 1) ? 'normal' : 'nowrap';\r\n        // ... (other UI color sync)\r\n\r\n        if (words.length === 0) {\r\n            wordDisplay.innerHTML = '<span class=\"placeholder\">Ready to flow</span>';\r\n            return;\r\n        }\r\n\r\n        let chunk = \"\";\r\n        let nextIndexChange = 0;\r\n\r\n        // Logic to get the current chunk based on mode\r\n        if (config.mode === 'sentence') {\r\n             // Find end of sentence from currentIndex\r\n             let tempIndex = currentIndex;\r\n             let collected = [];\r\n             \r\n             while (tempIndex < words.length) {\r\n                 const w = words[tempIndex];\r\n                 collected.push(w);\r\n                 // Check for sentence ending punctuation\r\n                 if (/[.?!]$/.test(w)) {\r\n                     break; \r\n                 }\r\n                 // Safety cap for extremely long sentences without punctuation (programming code etc)\r\n                 if (collected.length > 30) break; \r\n                 tempIndex++;\r\n             }\r\n             chunk = collected.join(' ');\r\n             nextIndexChange = collected.length; // How many words we consumed\r\n        } else {\r\n            // Word mode\r\n            chunk = words.slice(currentIndex, currentIndex + config.chunkSize).join(' ');\r\n            nextIndexChange = config.chunkSize;\r\n        }\r\n        \r\n        // Handle end of text\r\n        if (!chunk) {\r\n            if (config.loop) {\r\n                currentIndex = 0; \r\n                // Recurse to get first chunk\r\n                updateDisplay();\r\n                return;\r\n            } else {\r\n                pause();\r\n                currentIndex = 0; \r\n                return;\r\n            }\r\n        }\r\n        \r\n        // Apply ORP formatting to all words\r\n        if (config.mode === 'sentence') {\r\n            // For sentences, format each word with ORP\r\n            wordDisplay.innerHTML = formatChunk(chunk);\r\n        } else if (config.chunkSize === 1) {\r\n            wordDisplay.innerHTML = formatWord(chunk);\r\n        } else {\r\n            // Multi-word chunk - format each word\r\n            wordDisplay.innerHTML = formatChunk(chunk);\r\n        }\r\n\r\n        return { chunk, nextIndexChange };\r\n    }\r\n    \r\n    function updateProgress() {\r\n        if (words.length === 0) return;\r\n        \r\n        progressBar.max = words.length; \r\n        progressBar.value = currentIndex;\r\n        \r\n        const percent = Math.round((currentIndex / words.length) * 100) || 0;\r\n        progressText.innerText = `${percent}%`;\r\n        \r\n        const wordsLeft = words.length - currentIndex;\r\n        const minutesLeft = wordsLeft / config.wpm;\r\n        const mins = Math.floor(minutesLeft);\r\n        const secs = Math.ceil((minutesLeft - mins) * 60);\r\n        timeRemaining.innerText = (mins > 0 ? `${mins}m ` : \"\") + `${secs}s`;\r\n    }\r\n\r\n    let lastStepDelta = 1;\r\n\r\n    function scheduleNextStep(currentChunkText) {\r\n        if (!isPlaying) return;\r\n\r\n        // Base delay from WPM\r\n        let delay = getIntervalForChunk(currentChunkText, config.mode === 'sentence');\r\n        \r\n        // Apply pause scaling for punctuation\r\n        if (config.pauses && currentChunkText) {\r\n            const trimmedText = currentChunkText.trim();\r\n            const lastChar = trimmedText.slice(-1);\r\n            \r\n            // Strong pause for sentence-ending punctuation\r\n            if (['.', '!', '?'].includes(lastChar)) {\r\n                delay = delay * config.pauseScale;\r\n            } \r\n            // Medium pause for semicolons and colons\r\n            else if ([';', ':'].includes(lastChar)) {\r\n                delay = delay * (1 + (config.pauseScale - 1) * 0.7);\r\n            }\r\n            // Light pause for commas\r\n            else if ([','].includes(lastChar)) {\r\n                delay = delay * (1 + (config.pauseScale - 1) * 0.4);\r\n            }\r\n        }\r\n\r\n        timer = setTimeout(() => {\r\n            step();\r\n        }, delay);\r\n    }\r\n\r\n    function step() {\r\n        if (!isPlaying) return;\r\n        \r\n        // Advance by the amount determined in the PREVIOUS display update\r\n        currentIndex += lastStepDelta;\r\n        \r\n        if (currentIndex >= words.length && !config.loop) {\r\n            pause();\r\n            currentIndex = 0;\r\n            updateDisplay();\r\n            return;\r\n        }\r\n        \r\n        if (currentIndex >= words.length && config.loop) {\r\n            currentIndex = 0;\r\n        }\r\n\r\n        const { chunk, nextIndexChange } = updateDisplay();\r\n        lastStepDelta = nextIndexChange; // Store for next advance\r\n        \r\n        // Broadcast highlight to document\r\n        broadcastHighlight();\r\n\r\n        updateProgress();\r\n        scheduleNextStep(chunk);\r\n    }\r\n\r\n    function play() {\r\n        if (words.length === 0) return;\r\n        isPlaying = true;\r\n        playPauseBtn.innerHTML = '<i class=\"fas fa-pause\"></i>';\r\n        \r\n        // Update fullscreen button if active\r\n        const fsPlayBtn = document.getElementById('fsPlayPause');\r\n        if (fsPlayBtn) fsPlayBtn.innerHTML = '<i class=\"fas fa-pause\"></i>';\r\n        \r\n        // Display CURRENT index immediately\r\n        const { chunk, nextIndexChange } = updateDisplay();\r\n        lastStepDelta = nextIndexChange;\r\n        \r\n        // Initial broadcast\r\n        broadcastHighlight();\r\n        \r\n        scheduleNextStep(chunk);\r\n    }\r\n\r\n    function pause() {\r\n        isPlaying = false;\r\n        playPauseBtn.innerHTML = '<i class=\"fas fa-play\"></i>';\r\n        \r\n        if (timer) {\r\n            clearTimeout(timer);\r\n            timer = null;\r\n        }\r\n        // Keep highlight visible when paused - don't clear it\r\n    }\r\n\r\n    function loadText(text, indexToStart = 0) {\r\n        if (!text) return;\r\n        // Stop any current playback\r\n        pause();\r\n        // Clear and load new text\r\n        words = text.trim().split(/\\s+/);\r\n        currentIndex = indexToStart;\r\n        lastStepDelta = 1;\r\n        updateDisplay();\r\n        updateProgress();\r\n        // Highlight in original document\r\n        broadcastHighlight();\r\n    }\r\n\r\n    function clearText() {\r\n        pause();\r\n        words = [];\r\n        currentIndex = 0;\r\n        lastStepDelta = 1;\r\n        wordDisplay.innerHTML = '<span class=\"placeholder\">Ready to flow</span>';\r\n        progressBar.value = 0;\r\n        progressText.innerText = '0%';\r\n        timeRemaining.innerText = '--:--';\r\n        // Clear highlight in document\r\n        chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {\r\n            if (tabs[0]) { \r\n                chrome.tabs.sendMessage(tabs[0].id, {\r\n                    action: \"clearHighlight\"\r\n                }).catch(() => {});\r\n            }\r\n        });\r\n    }\r\n\r\n    function broadcastHighlight() {\r\n        if (words.length === 0) return;\r\n        \r\n        // Get the current chunk being displayed\r\n        let chunkText = '';\r\n        let contextBefore = '';\r\n        let contextAfter = '';\r\n        let wordCount = 1;\r\n        \r\n        if (config.mode === 'sentence') {\r\n            let tempIndex = currentIndex;\r\n            let collected = [];\r\n            while (tempIndex < words.length) {\r\n                const w = words[tempIndex];\r\n                collected.push(w);\r\n                if (/[.?!]$/.test(w)) break;\r\n                if (collected.length > 30) break;\r\n                tempIndex++;\r\n            }\r\n            chunkText = collected.join(' ');\r\n            wordCount = collected.length;\r\n        } else {\r\n            chunkText = words.slice(currentIndex, currentIndex + config.chunkSize).join(' ');\r\n            wordCount = config.chunkSize;\r\n        }\r\n        \r\n        // Get surrounding context for more accurate highlighting (5 words before and after)\r\n        const contextStart = Math.max(0, currentIndex - 5);\r\n        const contextEnd = Math.min(words.length, currentIndex + config.chunkSize + 5);\r\n        contextBefore = words.slice(contextStart, currentIndex).join(' ');\r\n        contextAfter = words.slice(currentIndex + config.chunkSize, contextEnd).join(' ');\r\n        \r\n        const highlightMsg = {\r\n            action: \"highlight\", \r\n            index: currentIndex,\r\n            text: chunkText,\r\n            wordCount: wordCount,\r\n            contextBefore: contextBefore,\r\n            contextAfter: contextAfter,\r\n            mode: config.mode\r\n        };\r\n        \r\n        chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {\r\n            if (tabs[0]) {\r\n                // Check if it's an extension page (PDF viewer)\r\n                const isExtensionPage = tabs[0].url && tabs[0].url.startsWith('chrome-extension://');\r\n                \r\n                if (isExtensionPage) {\r\n                    // Send via runtime for extension pages\r\n                    chrome.runtime.sendMessage(highlightMsg).catch(() => {});\r\n                } else {\r\n                    // Send via tabs for regular pages  \r\n                    chrome.tabs.sendMessage(tabs[0].id, highlightMsg).catch(() => {});\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // Apply UI from Config\r\n    function syncSettingsUI() {\r\n        // Mode UI\r\n        if (config.mode === 'sentence') {\r\n            modeWordBtn.classList.remove('active');\r\n            modeSentenceBtn.classList.add('active');\r\n            chunkSizeContainer.classList.add('hidden');\r\n        } else {\r\n            modeWordBtn.classList.add('active');\r\n            modeSentenceBtn.classList.remove('active');\r\n            chunkSizeContainer.classList.remove('hidden');\r\n        }\r\n\r\n        wpmInput.value = config.wpm;\r\n        wpmDisplay.innerText = config.wpm;\r\n        chunkSizeInput.value = config.chunkSize;\r\n        \r\n        togglePausesBtn.classList.toggle('active', config.pauses);\r\n        togglePausesBtn.innerText = config.pauses ? \"Pauses: On\" : \"Pauses: Off\";\r\n        \r\n        toggleLoopBtn.classList.toggle('active', config.loop);\r\n        toggleLoopBtn.innerText = config.loop ? \"Loop: On\" : \"Loop: Off\";\r\n        \r\n        pauseScaleSlider.value = config.pauseScale;\r\n        pauseScaleInput.value = config.pauseScale;\r\n        \r\n        fontSelect.value = config.font;\r\n        \r\n        fontScaleSlider.value = config.fontScale;\r\n        fontScaleInput.value = config.fontScale;\r\n        \r\n        bgColorPicker.value = config.bgColor;\r\n        bgColorText.value = config.bgColor;\r\n        \r\n        textColorPicker.value = config.textColor;\r\n        textColorText.value = config.textColor;\r\n        \r\n        focusColorPicker.value = config.focusColor;\r\n        focusColorText.value = config.focusColor;\r\n        \r\n        // Navigation settings\r\n        navModeSelect.value = config.navMode;\r\n        navAmountInput.value = config.navAmount;\r\n        updateNavTooltips();\r\n\r\n        updateDisplay(); // Force refresh styles\r\n    }\r\n\r\n    // --- Event Listeners ---\r\n    \r\n    // Mode Switching\r\n    modeWordBtn.addEventListener('click', () => {\r\n        config.mode = 'word';\r\n        syncSettingsUI();\r\n    });\r\n\r\n    modeSentenceBtn.addEventListener('click', () => {\r\n        config.mode = 'sentence';\r\n        syncSettingsUI();\r\n    });\r\n\r\n    // Toggle Buttons\r\n    togglePausesBtn.addEventListener('click', () => {\r\n        config.pauses = !config.pauses;\r\n        syncSettingsUI();\r\n    });\r\n\r\n    toggleLoopBtn.addEventListener('click', () => {\r\n        config.loop = !config.loop;\r\n        syncSettingsUI();\r\n    });\r\n\r\n    // Inputs Sync (Slider <-> Box)\r\n    pauseScaleSlider.addEventListener('input', (e) => {\r\n        config.pauseScale = parseFloat(e.target.value);\r\n        syncSettingsUI();\r\n    });\r\n    pauseScaleInput.addEventListener('change', (e) => {\r\n        config.pauseScale = parseFloat(e.target.value);\r\n        syncSettingsUI();\r\n    });\r\n\r\n    fontScaleSlider.addEventListener('input', (e) => {\r\n        config.fontScale = parseFloat(e.target.value);\r\n        syncSettingsUI();\r\n    });\r\n    fontScaleInput.addEventListener('change', (e) => {\r\n        config.fontScale = parseFloat(e.target.value);\r\n        syncSettingsUI();\r\n    });\r\n\r\n    // General Inputs\r\n    chunkSizeInput.addEventListener('change', (e) => {\r\n        config.chunkSize = parseInt(e.target.value) || 1;\r\n        syncSettingsUI();\r\n    });\r\n\r\n    fontSelect.addEventListener('change', (e) => {\r\n        config.font = e.target.value;\r\n        syncSettingsUI();\r\n    });\r\n\r\n    // Color Pickers\r\n    function updateColor(key, value) {\r\n        config[key] = value;\r\n        syncSettingsUI();\r\n    }\r\n\r\n    bgColorPicker.addEventListener('input', (e) => updateColor('bgColor', e.target.value));\r\n    bgColorText.addEventListener('change', (e) => updateColor('bgColor', e.target.value));\r\n    \r\n    textColorPicker.addEventListener('input', (e) => updateColor('textColor', e.target.value));\r\n    textColorText.addEventListener('change', (e) => updateColor('textColor', e.target.value));\r\n    \r\n    focusColorPicker.addEventListener('input', (e) => updateColor('focusColor', e.target.value));\r\n    focusColorText.addEventListener('change', (e) => updateColor('focusColor', e.target.value));\r\n\r\n    // Reset\r\n    resetSettingsBtn.addEventListener('click', () => {\r\n        config = {\r\n            wpm: 300,\r\n            chunkSize: 1,\r\n            mode: 'word',\r\n            pauses: true,\r\n            loop: false,\r\n            pauseScale: 1.5,\r\n            font: \"'Segoe UI', sans-serif\",\r\n            fontScale: 1,\r\n            bgColor: '#000000',\r\n            textColor: '#ffffff',\r\n            focusColor: '#e74c3c',\r\n            navMode: 'paragraphs',\r\n            navAmount: 1\r\n        };\r\n        syncSettingsUI();\r\n    });\r\n\r\n    // Navigation settings listeners\r\n    navModeSelect.addEventListener('change', (e) => {\r\n        config.navMode = e.target.value;\r\n        updateNavTooltips();\r\n    });\r\n    \r\n    navAmountInput.addEventListener('change', (e) => {\r\n        config.navAmount = parseInt(e.target.value) || 1;\r\n    });\r\n    \r\n    function updateNavTooltips() {\r\n        const modeLabels = {\r\n            'seconds': `${config.navAmount}s`,\r\n            'words': `${config.navAmount} words`,\r\n            'sentences': `${config.navAmount} sentence${config.navAmount > 1 ? 's' : ''}`,\r\n            'paragraphs': `${config.navAmount} para${config.navAmount > 1 ? 's' : ''}`\r\n        };\r\n        prevBtn.title = `Back ${modeLabels[config.navMode]}`;\r\n        nextBtn.title = `Forward ${modeLabels[config.navMode]}`;\r\n    }\r\n    updateNavTooltips(); // Initialize\r\n\r\n    // 1. Auto-load from active tab on open\r\n    async function fetchPageContent() {\r\n         // Clear existing content first\r\n         clearText();\r\n         \r\n         const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\r\n         if (tab) {\r\n             const url = tab.url || '';\r\n             \r\n             // Check if it's a PDF URL (browser's built-in PDF viewer)\r\n             const isPdfUrl = url.toLowerCase().endsWith('.pdf') || \r\n                              url.includes('blob:') ||\r\n                              url.includes('/pdf/') ||\r\n                              (tab.title && tab.title.endsWith('.pdf'));\r\n             \r\n             // Check if it's our PDF viewer (extension page)\r\n             const isOurViewer = url.startsWith('chrome-extension://') && url.includes('viewer.html');\r\n             const isExtensionPage = url.startsWith('chrome-extension://');\r\n             \r\n             if (isPdfUrl && !isOurViewer) {\r\n                 // Show message to use our PDF viewer\r\n                 wordDisplay.innerHTML = '<span class=\"placeholder\">Use PDF button â†’</span>';\r\n                 return;\r\n             }\r\n             \r\n             if (isOurViewer || isExtensionPage) {\r\n                 // Use runtime message for extension pages\r\n                 chrome.runtime.sendMessage({ action: \"getContent\" }, (response) => {\r\n                    if (chrome.runtime.lastError) {\r\n                        console.log(\"Could not get content from extension page:\", chrome.runtime.lastError.message);\r\n                        wordDisplay.innerHTML = '<span class=\\\"placeholder\\\">Click Read Page after loading PDF</span>';\r\n                    } else if (response && response.content) {\r\n                        loadText(response.content);\r\n                    } else if (response && response.error) {\r\n                        console.log(\"PDF not ready:\", response.error);\r\n                        wordDisplay.innerHTML = '<span class=\\\"placeholder\\\">Load a PDF file first</span>';\r\n                    } else {\r\n                        wordDisplay.innerHTML = '<span class=\\\"placeholder\\\">Load a PDF file first</span>';\r\n                    }\r\n                 });\r\n             } else {\r\n                 // Regular web page - use tabs message\r\n                 chrome.tabs.sendMessage(tab.id, { action: \"getContent\" }, (response) => {\r\n                    if (chrome.runtime.lastError) {\r\n                        // Script likely not injected in this tab (e.g. chrome:// URL or restricted)\r\n                        console.log(\"Could not auto-load content:\", chrome.runtime.lastError.message);\r\n                        wordDisplay.innerHTML = '<span class=\"placeholder\">Reload page</span>';\r\n                    } else if (response && response.content) {\r\n                        // Store paragraph boundaries if provided\r\n                        if (response.paragraphStarts) {\r\n                            storedParagraphStarts = response.paragraphStarts;\r\n                        }\r\n                        loadText(response.content);\r\n                    } else {\r\n                         wordDisplay.innerHTML = '<span class=\"placeholder\">No text found</span>';\r\n                    }\r\n                 });\r\n             }\r\n         }\r\n    }\r\n\r\n    fetchPageContent(); // Run on load\r\n\r\n    scanPageBtn.addEventListener('click', () => {\r\n        fetchPageContent();\r\n    });\r\n    \r\n    // Open PDF Viewer Button\r\n    openPdfBtn.addEventListener('click', () => {\r\n        // Open the PDF viewer in a new tab\r\n        const viewerUrl = chrome.runtime.getURL('viewer.html');\r\n        chrome.tabs.create({ url: viewerUrl });\r\n    });\r\n    \r\n    // Clear Button\r\n    clearTextBtn.addEventListener('click', () => {\r\n        clearText();\r\n    });\r\n\r\n    // 2. Play/Pause\r\n    playPauseBtn.addEventListener('click', () => {\r\n        if (isPlaying) pause();\r\n        else play();\r\n    });\r\n\r\n    // 3. Navigation\r\n    // Store paragraph starts from content script\r\n    let storedParagraphStarts = [0];\r\n    \r\n    function calculateNavJump(direction) {\r\n        let jump = 0;\r\n        \r\n        switch (config.navMode) {\r\n            case 'seconds':\r\n                // Convert seconds to words: words = (wpm / 60) * seconds\r\n                jump = Math.round((config.wpm / 60) * config.navAmount);\r\n                break;\r\n            case 'words':\r\n                jump = config.navAmount;\r\n                break;\r\n            case 'sentences':\r\n                // Find next/prev sentence boundary\r\n                let count = 0;\r\n                let idx = currentIndex;\r\n                if (direction > 0) {\r\n                    while (idx < words.length && count < config.navAmount) {\r\n                        if (/[.?!]$/.test(words[idx])) count++;\r\n                        idx++;\r\n                    }\r\n                    jump = idx - currentIndex;\r\n                } else {\r\n                    idx = Math.max(0, currentIndex - 1);\r\n                    while (idx > 0 && count < config.navAmount) {\r\n                        idx--;\r\n                        if (/[.?!]$/.test(words[idx])) count++;\r\n                    }\r\n                    jump = currentIndex - idx;\r\n                }\r\n                break;\r\n            case 'paragraphs':\r\n                // Use actual paragraph boundaries if available\r\n                if (storedParagraphStarts.length > 1) {\r\n                    if (direction > 0) {\r\n                        // Find next paragraph start after current position\r\n                        for (let p = 0; p < config.navAmount; p++) {\r\n                            let nextPara = storedParagraphStarts.find(s => s > currentIndex + jump);\r\n                            if (nextPara !== undefined) {\r\n                                jump = nextPara - currentIndex;\r\n                            } else {\r\n                                // No more paragraphs, jump to end\r\n                                jump = words.length - currentIndex;\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // Find previous paragraph start before current position\r\n                        let currentPos = currentIndex;\r\n                        for (let p = 0; p < config.navAmount; p++) {\r\n                            let prevPara = [...storedParagraphStarts].reverse().find(s => s < currentPos);\r\n                            if (prevPara !== undefined) {\r\n                                currentPos = prevPara;\r\n                            } else {\r\n                                currentPos = 0;\r\n                                break;\r\n                            }\r\n                        }\r\n                        jump = currentIndex - currentPos;\r\n                    }\r\n                } else {\r\n                    // Fallback: approximate paragraphs as 5 sentences\r\n                    const sentencesPerPara = 5;\r\n                    let pCount = 0;\r\n                    let pIdx = currentIndex;\r\n                    if (direction > 0) {\r\n                        let sCount = 0;\r\n                        while (pIdx < words.length && pCount < config.navAmount) {\r\n                            if (/[.?!]$/.test(words[pIdx])) {\r\n                                sCount++;\r\n                                if (sCount >= sentencesPerPara) {\r\n                                    pCount++;\r\n                                    sCount = 0;\r\n                                }\r\n                            }\r\n                            pIdx++;\r\n                        }\r\n                        jump = pIdx - currentIndex;\r\n                    } else {\r\n                        let sCount = 0;\r\n                        pIdx = Math.max(0, currentIndex - 1);\r\n                        while (pIdx > 0 && pCount < config.navAmount) {\r\n                            pIdx--;\r\n                            if (/[.?!]$/.test(words[pIdx])) {\r\n                                sCount++;\r\n                                if (sCount >= sentencesPerPara) {\r\n                                    pCount++;\r\n                                    sCount = 0;\r\n                                }\r\n                            }\r\n                        }\r\n                        jump = currentIndex - pIdx;\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        \r\n        return Math.max(1, jump); // At least 1 word\r\n    }\r\n    \r\n    prevBtn.addEventListener('click', () => {\r\n        const jump = calculateNavJump(-1);\r\n        currentIndex = Math.max(0, currentIndex - jump);\r\n        updateDisplay();\r\n        updateProgress();\r\n        broadcastHighlight();\r\n    });\r\n\r\n    nextBtn.addEventListener('click', () => {\r\n        const jump = calculateNavJump(1);\r\n        currentIndex = Math.min(words.length - 1, currentIndex + jump);\r\n        updateDisplay();\r\n        updateProgress();\r\n        broadcastHighlight();\r\n    });\r\n\r\n    restartBtn.addEventListener('click', () => {\r\n        pause();\r\n        currentIndex = 0;\r\n        updateDisplay();\r\n        updateProgress();\r\n    });\r\n\r\n    // 4. Settings & Overlays\r\n    wpmInput.addEventListener('input', (e) => {\r\n        config.wpm = parseInt(e.target.value);\r\n        wpmDisplay.innerText = config.wpm;\r\n        if (isPlaying) {\r\n             // Restart timer with new speed? \r\n             // With recursive setTimeout, it will auto-adjust on next step.\r\n             // But if we want instant feedback, we might pause/play.\r\n             // Actually, since we use recursion now, just letting it run is fine, \r\n             // but `scheduleNextStep` uses CURRENT wpm. So it will update after next word.\r\n        }\r\n    });\r\n\r\n    settingsBtn.addEventListener('click', () => {\r\n        // Sync UI before showing\r\n        syncSettingsUI();\r\n        settingsOverlay.classList.remove('hidden');\r\n    });\r\n\r\n    closeSettingsBtn.addEventListener('click', () => {\r\n        settingsOverlay.classList.add('hidden');\r\n    });\r\n    \r\n    // Close settings with X button\r\n    const closeSettingsX = document.getElementById('closeSettingsX');\r\n    closeSettingsX.addEventListener('click', () => {\r\n        settingsOverlay.classList.add('hidden');\r\n    });\r\n    \r\n    // Fullscreen functionality - opens dedicated fullscreen page in new window\r\n    function openFullscreenWindow() {\r\n        if (words.length === 0) {\r\n            // No content to show\r\n            return;\r\n        }\r\n        \r\n        // Pause current playback\r\n        const wasPlaying = isPlaying;\r\n        if (isPlaying) pause();\r\n        \r\n        // Send content to background script to open fullscreen window\r\n        chrome.runtime.sendMessage({\r\n            action: \"openFullscreen\",\r\n            words: words,\r\n            currentIndex: currentIndex,\r\n            config: {\r\n                wpm: config.wpm,\r\n                chunkSize: config.chunkSize,\r\n                mode: config.mode,\r\n                pauses: config.pauses,\r\n                pauseScale: config.pauseScale,\r\n                focusColor: config.focusColor,\r\n                navMode: config.navMode,\r\n                navAmount: config.navAmount\r\n            },\r\n            wasPlaying: wasPlaying\r\n        });\r\n    }\r\n\r\n    fullscreenBtn.addEventListener('click', openFullscreenWindow);\r\n    \r\n    // Listen for sync messages from fullscreen page\r\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n        if (message.action === \"syncFromFullscreen\") {\r\n            // Sync position from fullscreen\r\n            currentIndex = message.currentIndex || 0;\r\n            updateWordDisplay();\r\n            updateProgress();\r\n            updateScrollProgress();\r\n            \r\n            // Resume playing if it was playing before\r\n            if (message.wasPlaying) {\r\n                setTimeout(() => play(), 300);\r\n            }\r\n        }\r\n    });\r\n    \r\n    // ESC key to close overlays\r\n    document.addEventListener('keydown', (e) => {\r\n        if (e.key === 'Escape') {\r\n            settingsOverlay.classList.add('hidden');\r\n            manualInputOverlay.classList.add('hidden');\r\n        }\r\n    });\r\n\r\n    // 5. Manual Text Input\r\n    setTextBtn.addEventListener('click', () => {\r\n        manualInputOverlay.classList.remove('hidden');\r\n        manualTextInput.focus();\r\n    });\r\n\r\n    cancelInputBtn.addEventListener('click', () => {\r\n         manualInputOverlay.classList.add('hidden');\r\n    });\r\n\r\n    loadInputBtn.addEventListener('click', () => {\r\n        const text = manualTextInput.value;\r\n        if (text) {\r\n            loadText(text);\r\n        }\r\n        manualInputOverlay.classList.add('hidden');\r\n    });\r\n\r\n    // 6. Progress Bar Scrubbing\r\n    progressBar.addEventListener('input', (e) => {\r\n        const wasPlaying = isPlaying;\r\n        if (wasPlaying) pause();\r\n        currentIndex = parseInt(e.target.value);\r\n        updateDisplay();\r\n        updateProgress();\r\n        if (wasPlaying) play();\r\n    });\r\n\r\n    // 7. Context Menu Listener - \"Read from here\"\r\n    // Uses the clicked word index from content script for precise positioning\r\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n         // Handle PDF viewer sending content directly\r\n         if (message.action === \"loadPdfContent\") {\r\n             if (message.content) {\r\n                 if (message.paragraphStarts) {\r\n                     storedParagraphStarts = message.paragraphStarts;\r\n                 }\r\n                 loadText(message.content);\r\n                 showToast(`Loaded ${words.length.toLocaleString()} words from PDF`);\r\n             }\r\n             return;\r\n         }\r\n         \r\n         if (message.action === \"contextMenuTriggered\") {\r\n             const selectionText = message.selectionText?.trim();\r\n             const clickedWordIndex = message.clickedWordIndex ?? -1;\r\n             \r\n             // Clear current state first\r\n             pause();\r\n             \r\n             // Fetch fresh content from the page\r\n             chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\r\n                 if (!tabs[0]) return;\r\n                 \r\n                 // Reset highlight position on the page\r\n                 chrome.tabs.sendMessage(tabs[0].id, { action: \"resetHighlightPosition\" }).catch(() => {});\r\n                 \r\n                 chrome.tabs.sendMessage(tabs[0].id, { action: \"getContent\" }, (response) => {\r\n                     if (chrome.runtime.lastError || !response?.content) {\r\n                         if (selectionText) {\r\n                             loadText(selectionText);\r\n                         }\r\n                         return;\r\n                     }\r\n                     \r\n                     const fullText = response.content;\r\n                     const fullWords = fullText.trim().split(/\\s+/);\r\n                     \r\n                     // Store paragraph info if provided\r\n                     if (response.paragraphStarts) {\r\n                         storedParagraphStarts = response.paragraphStarts;\r\n                     }\r\n                     \r\n                     // Determine starting position\r\n                     let startIndex = 0;\r\n                     \r\n                     // Priority 1: Use clicked word index if available\r\n                     if (clickedWordIndex >= 0 && clickedWordIndex < fullWords.length) {\r\n                         startIndex = clickedWordIndex;\r\n                         console.log(\"Flow Mate: Starting from clicked word index\", startIndex);\r\n                     }\r\n                     // Priority 2: Try to match selection text\r\n                     else if (selectionText) {\r\n                         const cleanWord = (w) => w.toLowerCase().replace(/[^a-z0-9]/g, '');\r\n                         const selectionWords = selectionText.trim().split(/\\s+/);\r\n                         const selectionClean = selectionWords.map(cleanWord);\r\n                         \r\n                         // Match sequence of first 3 words\r\n                         const matchLen = Math.min(3, selectionClean.length);\r\n                         \r\n                         for (let i = 0; i < fullWords.length - matchLen + 1; i++) {\r\n                             let matches = true;\r\n                             for (let j = 0; j < matchLen; j++) {\r\n                                 if (cleanWord(fullWords[i + j]) !== selectionClean[j]) {\r\n                                     matches = false;\r\n                                     break;\r\n                                 }\r\n                             }\r\n                             if (matches) {\r\n                                 startIndex = i;\r\n                                 break;\r\n                             }\r\n                         }\r\n                     }\r\n                     \r\n                     // Load the full content at the determined position\r\n                     words = fullWords;\r\n                     currentIndex = startIndex;\r\n                     lastStepDelta = 1;\r\n                     updateDisplay();\r\n                     updateProgress();\r\n                     \r\n                     // Show toast notification\r\n                     const wordPreview = fullWords.slice(startIndex, startIndex + 3).join(' ');\r\n                     showToast(`Starting from: \"${wordPreview}...\"`);\r\n                     \r\n                     // Small delay before highlighting\r\n                     setTimeout(() => {\r\n                         broadcastHighlight();\r\n                     }, 100);\r\n                 });\r\n             });\r\n         }\r\n    });\r\n\r\n});\r\n"],"names":[],"ignoreList":[],"sourceRoot":""}